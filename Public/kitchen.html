<html>
  <head>
    <!-- SCRIPTS -->
    <script src="js/aframe-v0.8.2.min.js"></script>
    <script src="js/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/super-hands/dist/super-hands.min.js"></script>
    <script src="//cdn.rawgit.com/donmccurdy/aframe-physics-system/v3.1.2/dist/aframe-physics-system.min.js"></script>
    <script src="https://unpkg.com/aframe-event-set-component@^4.1.1/dist/aframe-event-set-component.min.js"></script>
    <script src="https://unpkg.com/aframe-physics-extras/dist/aframe-physics-extras.min.js"></script>
    <script src="https://rawgit.com/feiss/aframe-environment-component/master/dist/aframe-environment-component.min.js"></script>
    <script src="js/grabObj.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="js/timer.js"></script>
    <title>Kitchen</title>
    <script>
        var cutEvent = new Event('cut');
        var cookingEvent = new Event('cook');
        var stopCookingEvent = new Event('stopCooking');
        var pointsEvent = new Event('point');
        var gameOverEvent = new Event('gameOver');

        AFRAME.registerComponent('recipe', {
            schema: {
                cuttingIngredient: [],
                cookingIngredient: [],
                steps: {default: 0},
                points: {default: 100},
                myInterval: {default: null},
                gradeInfo: []
            },

            init: function(){
                const Context_AF = this;
                var obj = this.el;
                var objData = this.data;
                var myVar;//= setInterval(myTimer, 1000);

                cuttingIngredient = ["mushroom-entity", "bellPepper-entity", "egg-entity"];//

                cookingIngredient = ["mushroom-entity", "butter-entity", "egg-entity"];//
                //objData.steps = cookingIngredient.length;

                for(i = 0; i < cookingIngredient.length; i++){
                    document.getElementById(cookingIngredient[i]).addEventListener('cook', function(e){
                        cookingIngredientObj = this;
                        objData.steps -= 1;
                        if(this.getAttribute('ingredient').cookingStartTime == -1){
                            myVar = setInterval(function(){Context_AF.myCookingTimer(cookingIngredientObj)}, 1000);
                        }
                    }, false);

                    document.getElementById(cookingIngredient[i]).addEventListener('stopCooking', function(e){
                        Context_AF.myStopFunction();
                    }, false);
                }

                this.el.addEventListener("point", function(e){
                    objData.points -= 10;
                    console.log("POINTS = " + objData.points);
                    if(objData.points === 0){
                        console.log("FAILED");
                    }
                });

                this.el.addEventListener("gameOver", function(){
                    //Tally points
                    //console.log(10 * (objData.steps - document.getElementById('plate-entity').getAttribute('plate').ingerdients));//.ingerdients
                    //console.log(objData.points);
                    //steps not taken
                    /*
                    objData.points -= objData.steps * 10;
                    for(i = 0; i < cuttingIngredient.length; i++){
                        cuttingIngredientObj = document.getElementById(cuttingIngredient[i]);
                        if(cuttingIngredientObj.getAttribute('ingredient').sizeStart != cuttingIngredientObj.getAttribute('ingredient').sizeMin){
                            console.log(cuttingIngredientObj.getAttribute('id') + " was not cut to size");
                            //subtract points
                            objData.points -= 10;
                        }
                    }
                    for(i = 0; i < cookingIngredient.length; i++){
                        console.log(cookingIngredient[i]);
                        cookingIngredientObj = document.getElementById(cookingIngredient[i]);
                        if(cookingIngredientObj.getAttribute('ingredient').cookingTime > 0){
                            console.log(cookingIngredientObj.getAttribute('id') + " was undercooked");
                            //subtract points
                            objData.points -= 10;
                        }
                        if(cookingIngredientObj.getAttribute('ingredient').cookingTime < 0){
                            console.log(cookingIngredientObj.getAttribute('id') + " was overcooked");
                            //subtract points
                            objData.points -= 10;
                        }
                    }
                    //Context_AF.printGrade();*/
                });
            },

            myCookingTimer: function(e){
                var d = new Date();
                var t = d.getSeconds();
                if(t - e.getAttribute('ingredient').cookingStartTime > 0){
                    e.setAttribute("ingredient", {cookingStartTime: t});
                    e.setAttribute("ingredient", {cookingTime: e.getAttribute('ingredient').cookingTime - 1});
                    //console.log(e.getAttribute('ingredient').cookingTime);
                }
            },

            myStopFunction: function(){
                var objData = this.data;
                clearInterval(objData.myVar);
            }
        }),

        AFRAME.registerComponent('cookingimplement', {
            /*
                currentHeat: represents the current heat of the element
                maxHeat: represents the maximum heat the element can reach
                recieveHeat: 
                    if true then the element can't set it's own heat and needs to be placed on an element that can
                    if false then the element can set it's own heat and sends its current heat to the sendHeat object
                sendHeat: if recieveHeat is false then this value represents an object id that needs this elements heat 
            */
            schema:{
                currentHeat: {default: 0},
                maxHeat: {default: 100},
                recieveHeat: {default: false},
                sendHeat: {default: "null"}
            },

            init: function(){
                var obj = this.el;
                const Context_AF = this;
                var objData = this.data;
                //if true then it is an element like the burner or pan and it's heat is regulated by what it is on
                //if false then it is an elment like the burner knobs or oven gauge that sets the temerature for an element like the burner
                if(this.data.recieveHeat){
                    obj.addEventListener('collide', function(e){
                        if(e.detail.body.el.getAttribute('cookingimplement') !== null){
                            objData.currentHeat = e.detail.body.el.getAttribute('cookingimplement').currentHeat;
                            switch(objData.currentHeat){
                                case 90:
                                    obj.setAttribute("material", {color: "green"});    
                                    break;
                                case 180:
                                    obj.setAttribute("material", {color: "yellow"});    
                                    break;
                                case 270:
                                    obj.setAttribute("material", {color: "orange"});    
                                    break;
                                case 360:
                                    obj.setAttribute("material", {color: "red"});  
                                    break;
                            }
                        }
                    });
                }
                else{
                    obj.addEventListener('grab-start', function(e){
                        if(objData.currentHeat < 360){
                            objData.currentHeat += 90;
                            document.getElementById(objData.sendHeat).setAttribute("cookingimplement", {currentHeat: objData.currentHeat});
                            switch(objData.currentHeat){
                                case 90:
                                    document.getElementById(objData.sendHeat).setAttribute("material", {color: "green"});    
                                    break;
                                case 180:
                                    document.getElementById(objData.sendHeat).setAttribute("material", {color: "yellow"});    
                                    break;
                                case 270:
                                    document.getElementById(objData.sendHeat).setAttribute("material", {color: "orange"});    
                                    break;
                                case 360:
                                    document.getElementById(objData.sendHeat).setAttribute("material", {color: "red"});  
                                    break;
                            }
                        }
                        else{
                            objData.currentHeat = 0;
                            document.getElementById(objData.sendHeat).setAttribute("cookingimplement", {currentHeat: objData.currentHeat});
                            document.getElementById(objData.sendHeat).setAttribute("material", {color: "purple"});   
                        }
                    });
                }
            }
        }),

        AFRAME.registerComponent('ingredient', {
            /*
                heatTransfer: represents the heat needed to cook, once the value reaches 0 the ingredient is cooked if it goes below then it is overcooked 
                size: represents the size the recipe specifies the ingredient needs to be
                cookingImplementID
            */
            schema: {
                heatTransfer: {default: 0},
                cookingTemp: {default: 0},
                cookingTime: {default: 0},
                cookingStartTime: {default: -1},
                sizeMin: {default: 1},
                sizeStart: {default: 1},
                cookingImplementID: {default: "NULL"},
                plate: {default: false}
            },

            init: function(){
                const Context_AF = this;
                var obj = this.el;
                var objData = this.data;
                
                var d = new Date();
                var t= d.getTime();
                document.getElementById("recipe").setAttribute('recipe', {steps: document.getElementById("recipe").getAttribute('recipe').steps + (objData.sizeStart/objData.sizeMin)});
                console.log(document.getElementById("recipe").getAttribute('recipe').steps);//
                //Collision events
                obj.addEventListener('collide', function(e){
                    //Cutting events
                    if(objData.sizeStart > objData.sizeMin ){
                        //if the cube collides with the knife
                        if(e.detail.body.el.getAttribute('id') === 'knife-entity'){
                            
                            obj.dispatchEvent(cutEvent);
                            objData.sizeStart = objData.sizeStart / 2;
                            
                            let originalObjModel = obj.getAttribute('obj-model').obj;

                            let cutOne = document.createElement('a-entity');
                            let cutTwo = document.createElement('a-entity');

                            let cutObjPos = obj.getAttribute('position');
                            let cutObjScale = obj.getAttribute('scale');
                            
                            cutOne.setAttribute('obj-model', {obj: obj.getAttribute('obj-model').obj});
                            cutTwo.setAttribute('obj-model', {obj: obj.getAttribute('obj-model').obj});

                            cutOne.setAttribute('class', this.getAttribute('class'));
                            cutTwo.setAttribute('class', this.getAttribute('class'));

                            cutOne.setAttribute('ingredient', {heatTransfer: objData.heatTransfer, cookingTemp: objData.cookingTemp, cookingTime: objData.cookingTime, cookingStartTime: objData.cookingStartTime, sizeMin: objData.sizeMin, sizeStart: objData.sizeStart, cookingImplementID: objData.cookingImplementID});//
                            cutTwo.setAttribute('ingredient', {heatTransfer: objData.heatTransfer, cookingTemp: objData.cookingTemp, cookingTime: objData.cookingTime, cookingStartTime: objData.cookingStartTime, sizeMin: objData.sizeMin, sizeStart: objData.sizeStart, cookingImplementID: objData.cookingImplementID});//

                            cutOne.setAttribute('position', {x: cutObjPos.x, y: cutObjPos.y + 0.2, z: cutObjPos.z});
                            cutTwo.setAttribute('position', {x: cutObjPos.x + 0.1, y: cutObjPos.y + 0.2, z: cutObjPos.z});

                            cutOne.setAttribute('mixin', "objectHold");
                            cutTwo.setAttribute('mixin', "objectHold");

                            cutOne.setAttribute('material', {src: obj.getAttribute('material').src});
                            cutTwo.setAttribute('material', {src: obj.getAttribute('material').src});

                            cutOne.setAttribute('scale', {x: cutObjScale.x, y: cutObjScale.y , z: cutObjScale.z });
                            cutTwo.setAttribute('scale', {x: cutObjScale.x, y: cutObjScale.y , z: cutObjScale.z });

                            
                            let scene = document.getElementById("obj");//document.querySelector('a-scene');
                            scene.appendChild(cutOne);
                            scene.appendChild(cutTwo);

                            obj.setAttribute('delete-self', {delete: true});
                        }
                    }
                    if(e.detail.body.el.getAttribute('id') === objData.cookingImplementID){
                        if(obj.getAttribute('id') === 'egg-entity' && obj.getAttribute('ingredient').sizeStart > obj.getAttribute('ingredient').sizeMin){

                            let eggYolk = document.createElement('a-entity');
                            eggYolk.setAttribute('dynamic-body', {shape: "hull"});
                            obj.setAttribute('ingerdient', {sizeStart: obj.getAttribute('ingredient').sizeStart/2});
                            eggYolk.setAttribute('ingredient', {heatTransfer: objData.heatTransfer, cookingTemp: objData.cookingTemp, cookingTime: objData.cookingTime, cookingStartTime: objData.cookingStartTime, sizeMin: objData.sizeMin, sizeStart: objData.sizeStart, cookingImplementID: objData.cookingImplementID});
                            eggYolk.setAttribute('obj-model', {obj: "#eggYolk-obj"});
                            eggYolk.setAttribute('scale', {x: 0.01,y: 0.01, z:0.01});
                            eggYolk.setAttribute('position', obj.getAttribute('position'));
                            
                            let scene = document.getElementById("obj");//document.querySelector('a-scene');
                            scene.appendChild(eggYolk);

                            obj.setAttribute('delete-self', {delete: true});
                        }
                        Context_AF.heatObj(e);
                        //wrong heat
                        if(objData.heatTransfer !== objData.cookingTemp){
                            obj.dispatchEvent(pointsEvent);
                        }
                    }
                    else{
                        //No heat
                        obj.dispatchEvent(stopCookingEvent);
                        /* OUTDATED
                        if(objData.cookingTemp > 0 && objData.heatTransfer > 0){
                            if(objData.cookingTime > 0){
                                console.log("underCooked");
                                obj.dispatchEvent(pointsEvent);
                            }
                            if(objData.cookingTime < 0){
                                console.log("overCooked");
                                obj.dispatchEvent(pointsEvent);
                            }
                        }*/
                        objData.heatTransfer = 0;
                    }
                    if(e.detail.body.el.getAttribute('id') === 'plate-entity'){
                        Context_AF.checkStats();
                        obj.setAttribute('delete-self', {delete: true});
                    }
                });
            },

            tick: function(){
                
            },

            heatObj: function(e){
                var obj = this.el;
                this.data.heatTransfer = e.detail.body.el.getAttribute('cookingimplement').currentHeat;
                obj.dispatchEvent(cookingEvent);
                var d = new Date();
                var t = d.getSeconds();
                this.data.cookingStartTime = t;
                switch(this.data.heatTransfer){
                    case 90:
                        this.el.setAttribute("material", {color: "green"});    
                        break;
                    case 180:
                        this.el.setAttribute("material", {color: "yellow"});    
                        break;
                    case 270:
                        this.el.setAttribute("material", {color: "orange"});    
                        break;
                    case 360:
                        this.el.setAttribute("material", {color: "red"});  
                        break;
                }
            },

            checkStats: function(){
                var objData = this.data;
                if(!objData.plate){
                    objData.plate = true;
                    if(objData.cookingTime > 2){
                        console.log("UNDERCOOKED");
                        //remove points
                        document.getElementById('recipe').setAttribute('recipe', {points: document.getElementById('recipe').getAttribute('recipe').points - 10})
                        console.log(document.getElementById('recipe').getAttribute('recipe').points);
                    }
                    if(objData.cookingTime < -2){
                        console.log("OVERCOOKED");
                        //remove points
                        document.getElementById('recipe').setAttribute('recipe', {points: document.getElementById('recipe').getAttribute('recipe').points - 10})
                        console.log(document.getElementById('recipe').getAttribute('recipe').points);
                    }
                    if(objData.sizeStart !== objData.sizeMin){
                        console.log("WRONG SIZE");
                        //removePoints
                        document.getElementById('recipe').setAttribute('recipe', {points: document.getElementById('recipe').getAttribute('recipe').points - 10})
                        console.log(document.getElementById('recipe').getAttribute('recipe').points);
                    }
                }
            }
        }), 

        AFRAME.registerComponent('collision',{
            schema: {
                collision: {default: false}
            }
        }),

        AFRAME.registerComponent('phase-shift', {
            init: function () {
                var el = this.el
                el.addEventListener('gripdown', function (e) {
                    el.setAttribute('collision-filter', {collisionForces: true});
                })
                el.addEventListener('gripup', function () {
                    el.setAttribute('collision-filter', {collisionForces: false})
                    console.log("button let go");
                })
            }
        });
        
        AFRAME.registerComponent('delete-self', {
            schema:{
                delete: {default: false}
            },

            init: function(){

            },

            tick: function(){
                const Context_AF = this;
                var el = this.el;
                if(this.data.delete === true) {
                    Context_AF.deleteMyself();
                }
            },

            deleteMyself: function(){
                const Context_AF = this;
                Context_AF.el.parentNode.removeChild(Context_AF.el); 
            }
        });
        
        AFRAME.registerComponent('spawn', {
            schema:{
                objName: {default: ""}
            },

            init: function(){
                var obj = this.el;
                var objData = this.data;
                obj.addEventListener('grab-start', function(e){
                    let originalObjModel = obj.getAttribute('obj-model').obj;

                    let cutOne = document.createElement('a-entity');

                    //let cutObjPos = "-0.3 1.5 -0.1";
                    let cutObjScale = obj.getAttribute('scale');
                    
                    cutOne.setAttribute('obj-model', {obj: obj.getAttribute('obj-model').obj});

                    cutOne.setAttribute('class', this.getAttribute('class'));

                    cutOne.setAttribute('ingredient', {heatTransfer: objData.heatTransfer, cookingTemp: objData.cookingTemp, cookingTime: objData.cookingTime, cookingStartTime: objData.cookingStartTime, sizeMin: objData.sizeMin, sizeStart: objData.sizeStart, cookingImplementID: objData.cookingImplementID});//

                    cutOne.setAttribute('position', {x: 0, y: 2, z: 0});

                    cutOne.setAttribute('mixin', "objectHold");

                    cutOne.setAttribute('material', {src: obj.getAttribute('material').src});

                    cutOne.setAttribute('scale', {x: cutObjScale.x, y: cutObjScale.y , z: cutObjScale.z });

                    
                    let scene = document.getElementById("obj");//document.querySelector('a-scene');
                    scene.appendChild(cutOne);

                    obj.setAttribute('delete-self', {delete: true});
                });
            }
        });

        AFRAME.registerComponent('plate', {
            schema:{
                ingerdients: {default: 0},
                name: {default: ""}
            },

            init: function(){
                var obj = this.el;
                var objData = this.data;
                obj.addEventListener('collide', function(e){
                    if(e.detail.body.el.getAttribute('ingredient') !== null && objData.name !== e.detail.body.el.getAttribute('class')){
                        console.log(e.detail.body.el.getAttribute('class'));
                        objData.name = e.detail.body.el.getAttribute('class');
                        objData.ingerdients++;
                        console.log(objData.ingerdients);
                        if(objData.ingerdients > 0){//=== document.getElementById('recipe').getAttribute('recipe').steps
                            console.log("ALL STEPS DONE");
                            //spawn omlette
                            let omlette = document.createElement('a-entity');
                            omlette.setAttribute('static-body', {shape: "hull"});
                            omlette.setAttribute('obj-model', {obj: "#omlette-obj"});
                            omlette.setAttribute('scale', {x: 0.01,y: 0.01, z:0.01});
                            omlette.setAttribute('position', obj.getAttribute('position'));
                            
                            let scene = document.getElementById("obj");//document.querySelector('a-scene');
                            scene.appendChild(omlette);

                        }
                    }
                    
                });
            }
        });    
        
        let socket = io();

        socket.on('getPoints', function(){
            
            //var gameOverEvent = new Event('gameOver');
            let obj = document.getElementById('recipe');
            //obj.dispatchEvent(gameOverEvent);
            //console.log(-10 * (obj.getAttribute('recipe').steps - document.getElementById('plate-entity').getAttribute('plate').ingerdients));
            obj.setAttribute('recipe', {points: obj.getAttribute('recipe').points + (-10 * (obj.getAttribute('recipe').steps - document.getElementById('plate-entity').getAttribute('plate').ingerdients))})
            //obj.setAttribute('recipe', {points: obj.getAttribute('recipe') - (10 * (obj.getAttribute('recipe').steps - document.getElementById('plate-entity').getAttribute('plate').ingerdients))})
            //objData.points -= 10 * (objData.steps - document.getElementById('plate-entity').getAttribute('plate').ingerdients);
            var score = obj.getAttribute('recipe').points;
            socket.emit("test", score);
        });
    </script>
  </head>
  <body>
    
    <a-scene id="scene" physics timer="gamePart: kitchen" light="defaultLightsEnabled: true"><!---->
      <a-assets>
        <!--TEXTURES-->
        
        <img id="skymap" src="assets/materials/sunset_fairway_4k.jpg">
        <img id="bellPepper-img" src="assets/materials/bellPepper_base.png">
        <img id="mushroom-img" src="assets/materials/mushroom_baseColor.png">
        <img id="counter-img" src="assets/materials/CounterTopTexture.png">
        <img id="stove-img" src="assets/materials/CounterTopStoveTexture.png">
        
        <a-asset-item id="kitchen-mtl" src="assets/models/kitchenNEW.mtl"></a-asset-item>
        <!--<img id="kitchenWalls-img" src="assets/materials/kitchenWalls.png">-->

        <a-asset-item id="kitchenTopFront-obj" src="assets/models/kitchenTopFront.obj"></a-asset-item>
        <a-asset-item id="kitchenTopRight-obj" src="assets/models/kitchenTopRight.obj"></a-asset-item>
        <a-asset-item id="kitchenWalls-obj" src="assets/models/kitchenNEW.obj"></a-asset-item>
        <a-asset-item id="knife-obj" src="assets/models/knife.obj"></a-asset-item>
        <a-asset-item id="pan-obj" src="assets/models/pan.obj"></a-asset-item>
        <a-asset-item id="plate-obj" src="assets/models/plate.obj"></a-asset-item>
        <a-asset-item id="cuttingBoard-obj" src="assets/models/cuttingboard.obj"></a-asset-item>
        <!--RECIPE ELEMENTS-->
        <a-asset-item id="mushroom-obj" src="assets/models/mushroom.obj"></a-asset-item>
        <a-asset-item id="bellPepper-obj" src="assets/models/bellPepper.obj"></a-asset-item>
        <a-asset-item id="egg-obj" src="assets/models/egg.obj"></a-asset-item>
        <a-asset-item id="eggYolk-obj" src="assets/models/eggYolk.obj"></a-asset-item>
        <a-asset-item id="butter-obj" src="assets/models/butterStick.obj"></a-asset-item>
        <a-asset-item id="omlette-obj" src="assets/models/omlette_finished.obj"></a-asset-item>

        <!--STOVE ELEMENTS-->
        <a-asset-item id="stoveBase-obj" src="assets/models/stoveBase.obj"></a-asset-item>
        <a-asset-item id="frontRightBurner-obj" src="assets/models/frontRightBurner.obj"></a-asset-item>
        <a-asset-item id="frontRightBurnerKnob-obj" src="assets/models/frontRightBurnerKnob.obj"></a-asset-item>
        <a-asset-item id="frontLeftBurner-obj" src="assets/models/frontLeftBurner.obj"></a-asset-item>
        <a-asset-item id="frontLeftBurnerKnob-obj" src="assets/models/frontLeftBurnerKnob.obj"></a-asset-item>
        <a-asset-item id="backRightBurner-obj" src="assets/models/backRightBurner.obj"></a-asset-item>
        <a-asset-item id="backRightBurnerKnob-obj" src="assets/models/backRightBurnerKnob.obj"></a-asset-item>
        <a-asset-item id="backLeftBurner-obj" src="assets/models/backLeftBurner.obj"></a-asset-item>
        <a-asset-item id="backLeftBurnerKnob-obj" src="assets/models/backLeftBurnerKnob.obj"></a-asset-item>

        <!--MIXIN-->
        <a-mixin id="objectGrab" hoverable grabbable 
            event-set__hoveron="_event: hover-start; material.opacity: 0.7; transparent: true"
            event-set__hoveroff="_event: hover-end; material.opacity: 1; transparent: false"
            shadow collision></a-mixin>

        <a-mixin id="objectHold" hoverable grabbable stretchable draggable dynamic-body
            event-set__hoveron="_event: hover-start; material.opacity: 0.7; transparent: true"
            event-set__hoveroff="_event: hover-end; material.opacity: 1; transparent: false"
            shadow delete-self="delete: false;" collision></a-mixin>
            
        <a-mixin id="cube" 
                hoverable grabbable stretchable draggable
                event-set__hoveron="_event: hover-start; material.opacity: 0.7; transparent: true"
                event-set__hoveroff="_event: hover-end; material.opacity: 1; transparent: false"
                dynamic-body shadow delete-self="delete: false;" collision></a-mixin>
        
        <a-mixin id="touch"
                physics-collider phase-shift
                collision-filter="collisionForces: false"
                static-body="shape: sphere; sphereRadius: 0.02"
                super-hands="colliderEvent: collisions;
                                colliderEventProperty: els;
                                colliderEndEvent: collisions;
                                colliderEndEventProperty: clearedEls;">
      </a-assets>
        <!--PLAYER -->
        <a-entity>
            <a-camera positon="0 5 2">
                                    
            </a-camera>
            <a-entity id="rhand" mixin="touch"
                vive-controls="hand: right"
                oculus-touch-controls="hand: right"
                windows-motion-controls="hand: right">
            </a-entity>
            <a-entity id="lhand" mixin="touch"
                vive-controls="hand: left"
                oculus-touch-controls="hand: left"
                windows-motion-controls="hand: left">
            </a-entity>
        </a-entity>
        
        <a-entity id="sky" 
            position="0 0 0" 
            rotation="0 0 0" 
            scale="1 1 1" 
            geometry="primitive:sphere; radius:500;" 
            material="shader:flat; src:#skymap; side:back;">
        </a-entity>

        <a-entity id="lighting">
            <a-entity light="color: #ffd6aa; intensity: 0.5" position="-39 88 680" castShadow="True"></a-entity>
        </a-entity>

        <a-entity id="recipe" recipe></a-entity>
        <a-entity id="obj" position="0 0.7 -0.5">
            <a-entity id="kitchenTop">
                <a-entity static-body obj-model="obj: #kitchenTopFront-obj;" scale ="0.005 0.005 0.005"></a-entity>
                <a-entity static-body obj-model="obj: #kitchenTopRight-obj;" scale ="0.005 0.005 0.005"></a-entity>
            </a-entity>
            <a-obj-model  src="#kitchenWalls-obj"  scale ="0.005 0.005 0.005"></a-obj-model><!--mtl="#kitchen-mtl"-->
            <a-entity id="stoveBase-entity" obj-model="obj: #stoveBase-obj;" material="src: #stove-img" scale ="0.005 0.005 0.005"></a-entity>
            <a-entity  id="knife-entity" obj-model="obj: #knife-obj;" dynamic-body mixin="objectHold" position="0.8 1.2 -0.2" material="color: white" scale ="0.02 0.02 0.02"></a-entity><!--"0.5 1.4 -0.5"-->

            <a-entity id="mushroom-entity" class="mushroom" obj-model="obj: #mushroom-obj;" dynamic-body mixin="objectHold" position="-0.4 1.5 -0.1" scale ="0.01 0.01 0.01" material="src: #mushroom-img" ingredient="cookingTemp: 270; cookingTime: 10.0; sizeMin: 1; sizeStart: 1; heatTransfer: 0; cookingImplementID: pan-entity;"></a-entity>
            <a-entity id="egg-entity" class="egg" obj-model="obj: #egg-obj;" dynamic-body mixin="objectHold" position="-0.5 1.5 -0.1" scale ="0.02 0.02 0.02" material="color: white" ingredient="cookingTemp: 270; cookingTime: 10.0; sizeMin: 1; sizeStart: 1; heatTransfer: 0; cookingImplementID: pan-entity;"></a-entity>
            <a-entity id="butter-entity" class="butter" obj-model="obj: #butter-obj;" dynamic-body mixin="objectHold" position="-0.6 1.5 -0.2" scale ="0.01 0.01 0.01" material="color: yellow" ingredient="cookingTemp: 270; cookingTime: 10.0; sizeMin: 1; sizeStart: 1; heatTransfer: 0; cookingImplementID: pan-entity;"></a-entity>
            <a-entity id="cuttingBoard-entity" obj-model="obj: #cuttingBoard-obj" scale="0.01 0.01 0.01" static-body position="-0.4 0.55 -0.1"  material="color: white"></a-entity>
            

            <!--STOVE ENTITY-->
            <a-entity scale ="0.005 0.005 0.005">
                
                <a-entity static-body id="frontRightBurner-entity" obj-model="obj: #frontRightBurner-obj;" material="color: purple" cookingimplement="currentHeat: 0;maxHeat: 360;recieveHeat: true; sendHeat: NULL"></a-entity>
                <a-entity static-body id="frontLeftBurner-entity" obj-model="obj: #frontLeftBurner-obj;" material="color: purple" cookingimplement="currentHeat: 0;maxHeat: 360;recieveHeat: true; sendHeat: NULL"></a-entity>
                <a-entity static-body id="backRightBurner-entity" obj-model="obj: #backRightBurner-obj;" material="color: purple" cookingimplement="currentHeat: 0;maxHeat: 360;recieveHeat: true; sendHeat: NULL"></a-entity>
                <a-entity static-body id="backLeftBurner-entity" obj-model="obj: #backLeftBurner-obj;" material="color: purple" cookingimplement="currentHeat: 0;maxHeat: 360;recieveHeat: true; sendHeat: NULL"></a-entity>

                <a-entity id="backLeftBurnerKnob-entity" obj-model="obj: #backLeftBurnerKnob-obj;" static-body mixin="objectGrab" material="color: black" cookingimplement="currentHeat: 0;maxHeat: 360;recieveHeat: false;sendHeat: backLeftBurner-entity;"></a-entity>
                <a-entity id="backRightBurnerKnob-entity" obj-model="obj: #backRightBurnerKnob-obj;" static-body mixin="objectGrab" material="color: black" cookingimplement="currentHeat: 0;maxHeat: 360;recieveHeat: false;sendHeat: backRightBurner-entity;"></a-entity>
                <a-entity id="frontLeftBurnerKnob-entity" obj-model="obj: #frontLeftBurnerKnob-obj;" static-body mixin="objectGrab" material="color: black" cookingimplement="currentHeat: 0;maxHeat: 360;recieveHeat: false;sendHeat: frontLeftBurner-entity;"></a-entity>
                <a-entity id="frontRightBurnerKnob-entity" obj-model="obj: #frontRightBurnerKnob-obj;" static-body mixin="objectGrab" material="color: black" cookingimplement="currentHeat: 0;maxHeat: 360;recieveHeat: false;sendHeat: frontRightBurner-entity;"></a-entity>
            </a-entity>
            <a-entity id="pan-entity" obj-model="obj: #pan-obj;" dynamic-body="shape: hull" mixin="objectHold" position="0.4 2.0 -0.2" scale ="0.15 0.15 0.15" material="color: orange" cookingimplement="currentHeat: 0; maxHeat: 360; recieveHeat: true;"></a-entity>
            <a-entity id="plate-entity" obj-model="obj: #plate-obj" static-body position ="0 0.55 -0.2" scale="0.15 0.15 0.15" plate></a-entity>
            
        </a-entity>
        <a-entity id="bellPepperSpawn-entity" spawn class="bellPepper" mixin="objectGrab" obj-model="obj: #bellPepper-obj;" static-body position="0 1.5 -0.2" scale ="0.01 0.01 0.01" material="src: #bellPepper-img" delete-self ingredient="cookingTemp: 270; cookingTime: 10.0; sizeMin: 1; sizeStart: 1; heatTransfer: 90; cookingImplementID: pan-entity;"></a-entity>
        <a-entity id="timer" text="value: Time Left: ; align: center" scale="0.078 0.078 0.078" position="0 1.284 -0.695" visible="false"></a-entity>
    </a-scene>
    <script>
        
    </script>
  </body>
</html>